// 要解决 “两个逆序链表相加” 问题，核心是模拟人工加法的过程，结合链表 “逆序存储” 的特点（链表头对应数字的个位，天然符合加法 “从低位到高位计算” 的逻辑），关键在于处理 “逐位相加” 和 “进位” 两大核心点。以下是简要解析：
// 1. 问题本质理解

// 链表的 “逆序存储” 是关键优势：比如链表 l1 = [2,4,3]，实际表示数字 342（链表头 2 是个位，4 是十位，3 是百位）；l2 = [5,6,4] 表示 465。
// 加法需求：本质是计算两个数的和（如 342+465=807），再将结果以同样的逆序链表形式返回（807 逆序后为 [7,0,8]）。
// 2. 核心计算逻辑（3 步）

// 步骤 1：初始化工具

// 用一个虚拟头节点（如 dummy）简化结果链表的创建（无需单独处理 “头节点是否为空” 的判断），再用一个指针（如 curr）指向当前要构建的节点。
// 用一个进位变量（如 carry）记录每一位相加后的进位（初始为 0，因为个位相加默认无进位）。
// 步骤 2：逐位遍历与相加

// 同时遍历两个输入链表 l1 和 l2，直到两个链表都遍历完，且进位 carry 为 0（避免漏加最后一位的进位，如 999+99=1098，最后进位 1 需单独成节点）：
// 取当前节点值：若链表未遍历完，取节点值（如 l1.val）；若已遍历完（如 l1 短于 l2），取 0（相当于补 “0”）。
// 计算本位和：本位和 = l1当前值 + l2当前值 + carry（必须加进位，因为上一位可能有剩余）。
// 更新进位：carry = 本位和 // 10（如 7 则进位 0，10 则进位 1）。
// 构建结果节点：新节点值为 本位和 % 10（取个位），接在 curr 后面，再移动 curr 指针。
// 移动输入链表指针：若 l1/l2 未遍历完，移动到下一个节点。
// 步骤 3：返回结果

// 虚拟头节点的下一个节点（dummy.next）就是结果链表的头（因为虚拟头仅用于简化逻辑，本身不存储有效数据）。
// 3. 示例验证（以示例 1 为例）

// 输入：l1=[2,4,3]（342）、l2=[5,6,4]（465）
// 过程：
// 1. 个位：2+5+0=7 → 节点 7，carry=0；l1→4，l2→6
// 2. 十位：4+6+0=10 → 节点 0，carry=1；l1→3，l2→4
// 3. 百位：3+4+1=8 → 节点 8，carry=0；l1/l2 遍历完
// 4. carry=0，结束。结果：[7,0,8]（807），与示例一致。
// 4. 关键注意点

// 处理 “链表长度不一致”：短链表后续取 0 即可，无需特殊判断。
// 处理 “最后一位进位”：如示例 3（9999999+9999=10009998），最后进位 1 需单独加一个节点（结果最后一个节点 1）。
// 避免 “前导零”：题目保证输入无前置零，且相加后结果的前置零（如 0+0=0）会被逻辑自然处理（仅一个节点 0），无需额外处理。

function addTwoNumbers(
  l1: ListNode | null,
  l2: ListNode | null
): ListNode | null {
  if (!l1 && !l2) return null;
  let head: ListNode | null = null;
  let tail: ListNode | null = null;
  let carry = 0;
  while (l1 || l2) {
    const n1 = l1 ? l1.val : 0;
    const n2 = l2 ? l2.val : 0;
    const sum = n1 + n2 + carry;
    if (!head) {
      head = tail = new ListNode(sum % 10);
    } else {
      tail!.next = new ListNode(sum % 10);
      tail = tail!.next;
    }
    carry = Math.floor(sum / 10);
    if (l1) {
      l1 = l1.next;
    }
    if (l2) {
      l2 = l2.next;
    }
  }
  if (carry > 0) {
    tail!.next = new ListNode(carry);
  }
  return head;
}
